---
date: 
author:
- У.А. Шевченко
title: Проект «Выпуклая оболочка»
---

### Постановка задачи

Необходимо модифициаровать эталонный проект выпуклой оболочки,где бы вычислялось
 минимальное расстояние от фиксированной точки до выпуклой оболочки. Решение
должно быть индуктивным, что означает определение выпуклой оболочки и
вычисление её характеристик сразу после поступления очередной точки с
использованием методов теории индуктивных функций.

### Основные иди и методы решения

Нужно хранить минимальное расстояние от фиксированной точки до выпулой оболочки,
перевычисляя его при добавлении новой точки, причем это можно осущиствить индуктивно,
потому что зная минимальное расстояние на предыдущем шаге, при добавении новой точки
1) Оно может только ументшится (а у нас условие минимума).
2) При удалении освещённых рёбер, если минимальное расстояние(до удаления) было 
относителньо точки, пренадлежащему ему, то новое минимальное расстояние будет 
меньше либо никак не измениться, поэтому в рамках данной задчи можно пользоваться 
"жадной" логикой решения.
3) Если точка лежит внутри (включая границу), то искомое расстоение рвно  нулю. 
4) Фиксирвоанная точка может окаться внутри оболочки, это можно лего отслеживат 
путём проверки при удалении каждого освещенного ребра, не лежит ли она внутри
треугольника, образованного коцами ребра и добавляемой точкой. 
Если лежит, занчит и после удаления освещенных рёбер будет принадлежать
получивщейся оболочке. Я проверка принадлежности точки треуголника осуществляется
векторным методом.
5) Прерассчет расстояния от точки до нового ребра (после удаления освещённых рёбер)
тоже осуществим векторым способом. Если точка лежит в части плоскости, ограниченной 
прямыми, препендикулрным ребру и проходящим чрез его концы, то минимальным расстоянием 
буедт длинна перпендикуляра из фиксированой точки до  ребра. Если нет, то искомым 
расстоянием будет минимальное из длинн отрезков, соединяющих концы ребра с фиксированной
точкой.  

### Векторный метод

1 )Для того чтобы определить лежит ли точка P внутри треугольника ABC мы вычислим 
3 векторных произведения: ABxAP, BCxBP and CAxCP. Так как наш треугольник и точка 
в 2-мерном пространстве на плоскости, третья координата z для трехмерного 
пространства равна нулю. Согласно формуле [1] мы можем не вычислять координаты x и y 
для векторного произведения, если координата z векторов-множителей 
равна нулю - координаты x и y результата в этом случае всегда равны нулю 
(результирующий псевдо-вектор перпендикулярен плоскости треугольника). 
Знак результата произведения для оставшейся координаты (z) зависит от 
относительного положения умножаемых векторов. Если первый вектор 
(в нашем случае это сторона треугольника) находится правее второго вектора
(вектор из вершины в точку P), то координата z результата будет положительна,
если первый вектор будет левее второго - отрицательна, и в противном случае, 
если оба вектора идут в одном и том же направлении, результат будет равен нулю.
Получив результаты по трем векторным произведениям, нам остается их проанализировать, 
чтобы понять лежит ли точка внутри треугольника:
Если мы имеем и положительные и отрицательные результаты, точка лежит вне треугольника, 
если результаты только положительные или только отрицательные, точка - внутри.

2) Длинна перпендикулярат, проведенного из точки к прямой равна модулю скалярного 
произведения единичного вектора нормали к прмой на вектор, конец и начало котрого 
соединяют точку, принадлежащую прямой и фиксировангую точку (из котрой опущен
препендикуляр). Вектор нормали определяется неоднозначно, для удобства 
если p = {x, y}  - направляющий вектор прямой, возьмем
такой вектор номрали n = {y, -x}, и нормируем до едиричного, поделив координаты 
на номрму n.


### Краткий комментарий к решению

- Ключевое понятие проекта: *освещённость ребра из точки* 
- Вспомогательные классы:
    - `R2Point` — точка на плоскости
    - `Deq` — контейнер дек (double ended queue)
- Основные классы:
    - `Figure` — «абстрактная» фигура
    - `Void` — нульугольник
    - `Point` — одноугольник
    - `Segment` — двуугольник
    - `Polygon` — многоугольник
- Файлы проекта:
    - `README.md` — данный файл
    - `README.html` — полученный из файла `README.md` `html`-файл
    - `r2point.py` — реализация класса `R2Point`, вспомогательный функционал
    для разных классво проекта
    - `deq.py` —  реализация класса `Deq`
    - `convex.py` — реализация основных классов
    - `run_convex.py` — файл запуска
    - `tk_drawer.py` — интерфейс к графической библиотеке
    - `run_tk_convex.py` — файл запуска с использованием графики
    - `tests/test_r2point.py` — тесты к классу `R2Point`
    - `tests/test_convex.py` — тесты к основным классам

Файлы `run_tk_convex.py` и `run_tk_convex.py` являются исполняемыми (они имеют
бит `x`), в первой строке каждого из них используется [шебанг](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix)) и команда `env` с
опцией (ключом) `-S`. Это обеспечивает передачу интерпретатору языка Python
опции (ключа) `-B`, отменяющего генерацию `pyc`-файлов в директории
`__pycache__`.


### Соблюдение соглашений о стиле программного кода

Для языка Python существуют [соглашения о стиле
кода](https://www.python.org/dev/peps/pep-0008/). Они являются лишь
рекомендациями (интерпретатор игнорирует их нарушение), но основную их
часть при написании программ целесообразно соблюдать. Существует простой
способ проверить соблюдение считающегося правильным
стиля записи кода с помощью утилиты (программы) `pycodestyle`. Утилита
`yapf` позволяет даже изменить код в соответствии с этими соглашениями.

Команда 

    pycodestyle r2point.py

позволяет, например, проверить соблюдение стиля для файла `r2point.py`.
С помощью очень мощной и часто используемой утилиты `find` проверить
корректность стиля всех файлов проекта можно так:

    find . -name '*.py' -exec pycodestyle {} \;

Эта команда находит все файлы с расширением `py` и запускает программу
`pycodestyle` последовательно для каждого из них.

### Запуск тестов

Уже известная нам команда (см. материал, посвящённый тестированию программ)

    python -B -m pytest -p no:cacheprovider tests

запускает pytest, выполняя все начинающиеся с `test` методы классов,
имена которых начинаются с `Test`, содержащиеся во всех файлах `test_*.py`
директории `tests`.

### Запуск программы

`./run_convex.py`

### Запуск программы с графическим интерфейсом

`./run_tk_convex.py`
